"use client";

import { Button } from "@/components/ui/button";
import {
  FileUpload,
  FileUploadDropzone,
  FileUploadItem,
  FileUploadItemDelete,
  FileUploadItemMetadata,
  FileUploadItemPreview,
  FileUploadList,
  FileUploadTrigger,
} from "@/components/ui/file-upload";
import { Upload, X } from "lucide-react";
import * as React from "react";
import { toast } from "sonner";

// 用於計算檔案雜湊值的函式
import { md5 } from 'js-md5';

async function calculateFileHash(file: File): Promise<{
  sha256: string;
  sha1: string;
  md5: string;
}> {
  // 將檔案內容讀取為 ArrayBuffer
  const arrayBuffer = await file.arrayBuffer();
  
  // 使用 Web Crypto API 計算 SHA-256
  const sha256Buffer = await crypto.subtle.digest("SHA-256", arrayBuffer);
  
  // 使用 Web Crypto API 計算 SHA-1
  const sha1Buffer = await crypto.subtle.digest("SHA-1", arrayBuffer);
  
  // 使用 js-md5 計算 MD5 (因為 Web Crypto API 不支援 MD5)
  const md5Hex = md5(new Uint8Array(arrayBuffer));
  
  // 將二進制雜湊值轉換為十六進制字串
  const sha256Hex = Array.from(new Uint8Array(sha256Buffer))
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");
    
  const sha1Hex = Array.from(new Uint8Array(sha1Buffer))
    .map(b => b.toString(16).padStart(2, "0"))
    .join("");
  
  return {
    sha256: sha256Hex,
    sha1: sha1Hex,
    md5: md5Hex
  };
}

// 檔案上傳資料介面
interface FileUploadData {
  file: File;
  sha256: string;
  sha1: string;
  md5: string;
  upload_time: string;
}

export function MalwareUploader() {
  // 檔案狀態
  const [files, setFiles] = React.useState<File[]>([]);
  // 上傳中狀態
  const [isUploading, setIsUploading] = React.useState(false);
  // 處理後的檔案資料
  const [processedFiles, setProcessedFiles] = React.useState<FileUploadData[]>([]);
  // 當檔案被拒絕時的處理函式
  const onFileReject = React.useCallback((file: File, message: string) => {
    const filename = file.name.length > 20 ? `${file.name.slice(0, 20)}...` : file.name;
    toast.error(message, {
      description: `"${filename}" has been rejected`,
    });
  }, []);
  // 檔案變更時處理函式
  React.useEffect(() => {
    async function processFiles() {
      // 清空先前處理的檔案
      setProcessedFiles([]);
      
      // 處理每個檔案
      const newProcessedFiles: FileUploadData[] = [];
      
      for (const file of files) {
        try {
          // 計算檔案的雜湊值
          const hashes = await calculateFileHash(file);
          
          // 建立當前時間戳記
          const timestamp = new Date().toISOString();
          
          newProcessedFiles.push({
            file,
            ...hashes,
            upload_time: timestamp
          });        } catch (error) {
          console.error(`Error processing file ${file.name}:`, error);
          toast.error(`File Processing Error`, {
            description: `"${file.name}" could not calculate hash values.`
          });
        }
      }
      
      setProcessedFiles(newProcessedFiles);
    }
    
    if (files.length > 0) {
      processFiles();
    }
  }, [files]);
  // 上傳檔案到後端
  const handleUpload = async () => {
    if (processedFiles.length === 0) return;
    
    setIsUploading(true);
    
    try {
      for (const fileData of processedFiles) {
        // 為每個檔案創建 FormData
        const formData = new FormData();
        formData.append("file", fileData.file);
        formData.append("sha256", fileData.sha256);
        formData.append("sha1", fileData.sha1);
        formData.append("md5", fileData.md5);
        formData.append("upload_time", fileData.upload_time);
        
        // 發送到後端 API (目前只模擬成功，實際應替換為真實 API 端點)
        // 實際環境中應該使用以下程式碼：
        // const response = await fetch('/api/samples/upload', {
        //   method: 'POST',
        //   body: formData
        // });
          // 如果需要檢查回應
        // if (!response.ok) throw new Error('Upload Failed');
        
        // 模擬 API 呼叫延遲
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        // 顯示成功訊息
        toast.success(`Sample Uploaded Successfully`, {
          description: `SHA256: ${fileData.sha256.slice(0, 10)}...`
        });
      }
      
      // 清空檔案列表
      setFiles([]);
      setProcessedFiles([]);    } catch (error) {
      console.error("Error during upload:", error);
      toast.error("Upload Failed", {
        description: "Could not connect to server. Please try again later."
      });
    } finally {
      setIsUploading(false);
    }
  };

  return (
    <div className="space-y-6">      <FileUpload
        maxFiles={2}
        maxSize={5 * 1024 * 1024} // 5MB
        className="w-full"
        value={files}
        onValueChange={setFiles}
        onFileReject={onFileReject}
        multiple
      >
        <FileUploadDropzone>
          <div className="flex flex-col items-center gap-1 text-center">
            <div className="flex items-center justify-center rounded-full border p-2.5">
              <Upload className="size-6 text-muted-foreground" />
            </div>
            <p className="font-medium text-sm">Drop files here</p>
            <p className="text-muted-foreground text-xs">
              or browse files (max 2 files, 5MB each)
            </p>
          </div>
          <FileUploadTrigger asChild>
            <Button variant="outline" size="sm" className="mt-2 w-fit">
              Browse Files
            </Button>
          </FileUploadTrigger>
        </FileUploadDropzone>
        
        <FileUploadList>
          {files.map((file, index) => {
            const processedFile = processedFiles.find(pf => pf.file === file);
            
            return (
              <FileUploadItem key={index} value={file}>
                <FileUploadItemPreview />
                <div className="flex flex-col flex-1 overflow-hidden">
                  <FileUploadItemMetadata />
                  {processedFile && (
                    <div className="mt-1 text-xs space-y-0.5 text-muted-foreground">
                      <p className="truncate">
                        <span className="font-semibold">SHA256:</span> {processedFile.sha256}
                      </p>
                      <p className="truncate">
                        <span className="font-semibold">SHA1:</span> {processedFile.sha1}
                      </p>
                      <p className="truncate">
                        <span className="font-semibold">MD5:</span> {processedFile.md5}
                      </p>
                    </div>
                  )}
                </div>
                <FileUploadItemDelete asChild>
                  <Button variant="ghost" size="icon" className="size-7">
                    <X />
                  </Button>
                </FileUploadItemDelete>
              </FileUploadItem>
            );
          })}
        </FileUploadList>
      </FileUpload>      {processedFiles.length > 0 && (
        <Button 
          className="w-full" 
          onClick={handleUpload}
          disabled={isUploading}
        >
          {isUploading ? "Uploading..." : "Upload Sample Files"}
        </Button>
      )}
    </div>
  );
}
